/** De Bruijn-Erdos checker for Nauty-generated graphs.

Example usage:

    NAUTY="../nauty26r11"
    $NAUTY/geng -b -C 6 | ./dbe | $NAUTY/showg -A
**/

#include <algorithm>
#include <chrono>
#include <climits>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include <gflags/gflags.h>

#include "src/analysis.h"
#include "src/common.h"
#include "src/graphs.h"

DEFINE_bool(v, false, "Verbose analysis");
DEFINE_bool(q, false, "Quiet mode");
DEFINE_bool(p, true, "Include universal line in line counts");
DEFINE_bool(n, false, "Do not output metric spaces with |X| lines");
DEFINE_int32(nmin, 0,
             "Only output metric spaces with at least this many distinct lines");
DEFINE_int32(nmax, INT_MAX,
             "Only output metric spaces with at most this many distinct lines");
DEFINE_int32(dmin, 0,
             "Only count lines generated by pairs of vertices at at least this "
             "distance");
DEFINE_int32(dmax, INT_MAX,
             "Only count lines generated by pairs of vertices at at "
             "most this distance");
DEFINE_bool(u, false, "Do not output metric spaces with a universal line");
DEFINE_int32(dumin, 0,
             "Among pairs that generate the universal line, only count pairs "
             "at at most this distance");
DEFINE_int32(dumax, INT_MAX,
             "Among pairs that generate the universal line, only count pairs "
             "at at least this distance");
DEFINE_int32(zmin, INT_MIN,
             "Only output metric spaces with a AMRZ gap of at least this number");
DEFINE_int32(zmax, INT_MAX,
             "Only output metric spaces with a AMRZ gap of at most this number");
DEFINE_int32(o, 0, "Output format");

void ParseCommandLineFlags(int argc, char *argv[]) {
  gflags::SetUsageMessage("De Bruijn-Erdos checker.");
  gflags::SetVersionString("1.0.0");
  gflags::ParseCommandLineFlags(&argc, &argv, true);
}

std::string Values(const MetricSpaceInfo &info, int num_bridges) {
  std::vector<int> values = {info.num_lines,           info.num_lines_dist1,
                             info.num_lines_dist2,     info.num_universal,
                             info.num_universal_dist1, info.num_universal_dist2,
                             num_bridges};

  std::stringstream ss;
  ss << std::setw(2) << info.num_vertices;
  for (int value : values) {
    ss << "," << std::setw(2) << value;
  }
  return ss.str();
}

bool ReadMetricSpace(Graph& graph, DistanceMatrix& distance_matrix, std::string& label) {
  boost::optional<std::string> line;
  do {
    line = ReadLine();
    if (!line) {
      return false;
    }
  } while (line.get().length() == 0);

  std::stringstream stream(line.get());
  int num_points;
  stream >> num_points;
  distance_matrix = DistanceMatrix(num_points);
  graph = Graph(num_points);  // dummy graph
  DistanceMatrixMap dist(distance_matrix, graph);
  for (int i = 0; i < num_points; ++i) {
    for (int j = i+1; j < num_points; ++j) {
      if (!stream) {
        Error("Unexpected end of line");
      }
      stream >> dist[i][j];
      dist[j][i] = dist[i][j];
    }
  }
  stream >> label;
  return true;
}

int main(int argc, char *argv[]) {
  ParseCommandLineFlags(argc, argv);

  if (!FLAGS_q) {
    std::cerr << ">A dbe" << std::endl;
  }

  AnalysisOptions options;
  options.dmin = FLAGS_dmin;
  options.dmax = FLAGS_dmax;
  options.dumin = FLAGS_dumin;
  options.dumax = FLAGS_dumax;
  options.count_bridges = (FLAGS_o == 2);
  options.count_lines_by_distance = (FLAGS_o == 2);
  options.include_universal_in_lines = FLAGS_p;
  options.skip_spaces_with_universal_line = FLAGS_u;
  options.verbose = FLAGS_v;

  auto begin_time = Clock::now();
  unsigned long long num_metric_spaces = 0;
  unsigned long long num_output_metric_spaces = 0;
  Graph graph(0);
  DistanceMatrix distance_matrix(0);
  std::string label;
  while (ReadMetricSpace(graph, distance_matrix, label)) {
    ++num_metric_spaces;
    const int num_vertices = boost::num_vertices(graph);

    DistanceMatrixMap dist(distance_matrix, graph);
    MetricSpaceInfo info;
    bool valid = AnalyzeMetricSpace(num_vertices, dist, options, &info);

    if ((!FLAGS_q) && (num_metric_spaces % 10000000 == 0)) {
      std::cerr << ">Z (in-progress) dbe analyzed " << num_metric_spaces
                << " metric spaces in " << GetMillisecondsSince(begin_time) / 1000.0
                << " seconds " << std::endl;
    }

    // Determine whether to output this metric space.
    if (!valid) {
      continue;
    } else if (FLAGS_u && info.num_universal > 0) {
      // Skip because this metric space has a universal line.
      continue;
    } else if (FLAGS_n && info.num_lines >= info.num_vertices) {
      // Skip because this metric space has as many lines as vertices.
      continue;
    } else if ((info.amrz_gap < FLAGS_zmin) || (info.amrz_gap > FLAGS_zmax)) {
      // Skip because this metric space an AMRZ gap outside the requested range.
      continue;
    } else if ((info.num_lines < FLAGS_nmin) || (info.num_lines > FLAGS_nmax)) {
      continue;
    }

    ++num_output_metric_spaces;
    if (FLAGS_o == 0) {
      if (!FLAGS_q) {
        std::cerr << "Metric space " << num_metric_spaces << " (output # " << num_output_metric_spaces
                  << ") has " << info.num_lines
                  << " lines (from " << info.num_line_pairs << " pairs) and "
                  << info.num_universal << " mighty pairs (AMRZ gap "
                  << info.amrz_gap << ")" << std::endl;
      }
      std::cout << label << std::endl;
    } else if (FLAGS_o == 1) {
      std::cout << info.num_lines << "," << info.num_universal << ","
                << info.amrz_gap << std::endl;
    }
  }

  if (!FLAGS_q) {
    std::cerr << ">Z dbe analyzed " << num_metric_spaces << " metric spaces in "
              << GetMillisecondsSince(begin_time) / 1000.0 << " seconds"
              << std::endl;
  }
  gflags::ShutDownCommandLineFlags();
  return 0;
}
